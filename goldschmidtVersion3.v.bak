module goldschmidtVersion3 #(parameter X =23) (a,b,start,clk,clrn,q,ready,yn);
localparam mant_bits = (X == 23) ? 23  : 52;

input [mant_bits - 1:0] a; // dividend: .1xxx...x
input [mant_bits - 1:0] b; // divisor: .1xxx...x
input start; // start
input clk, clrn; // clock and reset
output [mant_bits - 1:0] q; // quotient: x.xxx...x
output reg busy; // busy

output reg ready; // ready
output [2:0] count; // counter
output [mant_bits - 1:0] yn; // .11111...1
reg [(2 *mant_bits) - 1:0] reg_a; // x.xxxx...x
reg [(2 *mant_bits) - 1:0] reg_b; // 0.xxxx...x
reg [2:0] count;
wire [(2 *mant_bits) - 1:0] two_minus_yi = ~reg_b + 1’b1; // 1.xxxx...x (2 - yi)
wire [(4 *mant_bits) - 1:0] xi = reg_a * two_minus_yi; // 0x.xxx...x
wire [(4 *mant_bits) - 1:0] yi = reg_b * two_minus_yi; // 0x.xxx...x
assign q = reg_a[(2 *mant_bits) - 1:mant_bits - 1] + |reg_a[31:29]; // rounding up
assign yn = reg_b[(2 *mant_bits) - 2:mant_bits - 2];
always @ (posedge clk or negedge clrn) begin
if (!clrn) begin
busy <= 0;
ready <= 0;
end else begin
if (start) begin
reg_a <= {1’b0,a,31’b0}; // 0.1x...x0...0
reg_b <= {1’b0,b,31’b0}; // 0.1x...x0...0
busy <= 1;
ready <= 0;
count <= 0;
end else begin
reg_a <= xi[(4 *mant_bits) - 2:(2 *mant_bits) - 1]; // x.xxx...x
reg_b <= yi[(4 *mant_bits) - 2:(2 *mant_bits) - 1]; // 0.xxx...x
count <= count + 3’b1; // count++
if (count == 3’h4) begin // finish
busy <= 0;
ready <= 1; // q is ready
end
end
end
end
endmodule